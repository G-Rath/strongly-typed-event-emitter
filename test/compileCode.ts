import ts from 'typescript';
import TSFileLoader from './TSFileLoader';

export interface CompilerOutput {
  fileName: string;
  data: string;
  writeByteOrderMark: boolean;
}

export interface CompilerResults {
  diagnostics: string[];
  outputs: CompilerOutput[];
}

/**
 * Builds a message string out of the given `messageText`.
 *
 * This navigates the message chain, if one exists.
 *
 * @param {string | ts.DiagnosticMessageChain} messageText
 *
 * @return {string}
 */
const buildDiagnosticMessageString = (messageText: string | ts.DiagnosticMessageChain): string => {
  if (typeof messageText === 'string') {
    return messageText;
  }

  const chain: string[] = [messageText.messageText];
  let message: ts.DiagnosticMessageChain | undefined = messageText.next;

  while (message) {
    chain.push(`${'\t'.repeat(chain.length + 13)}${message.messageText}`);

    message = message.next;
  }

  return chain.join('\n');
};

/**
 * Formatter for diagnostic information generated by `TypeScript` when compiling code.
 *
 * @param {ts.DiagnosticRelatedInformation} diagnosticInfo
 *
 * @return {string}
 */
const diagnosticsFormatter = (diagnosticInfo: ts.DiagnosticRelatedInformation): string => {
  const message = ['unknown file', ' '];

  if (diagnosticInfo.file) {
    message.shift();
    message.unshift(
      diagnosticInfo.file.fileName,
      `#L${diagnosticInfo.file.getLineAndCharacterOfPosition(diagnosticInfo.start || 0).line}`
    );
  }

  message.push(
    `TS${diagnosticInfo.code}:`,
    ' ',
    buildDiagnosticMessageString(diagnosticInfo.messageText)
  );

  return message.join('');
};

/**
 * Compiles the given `code` as if it was read from a `TypeScript` file.
 *
 * Files are loaded using the `tsFileLoader`.
 *
 * Since by typically `tsc` reads the contents of files itself from disk,
 * this uses a custom `CompilerHost` that just returns the given `code`
 * when asked to read the contents of the file named `_source.ts`.
 *
 * @param {string} code
 * @param {TSFileLoader} tsFileLoader
 * @param {ts.CompilerOptions & Required<Pick<ts.CompilerOptions, "target">>} [compilerOptions]
 *
 * @return {CompilerResults}
 */
export const compileCode = (
  code: string,
  tsFileLoader: TSFileLoader,
  compilerOptions: ts.CompilerOptions & Required<Pick<ts.CompilerOptions, 'target'>> = { target: ts.ScriptTarget.ES2015 }
): CompilerResults => {
  const outputs: CompilerOutput[] = [];
  const sourceFile = '_source.ts';

  tsFileLoader.manuallyAddFile(sourceFile, code);

  const compilerHost: ts.CompilerHost = {
    fileExists: fileName => tsFileLoader.isLoadableFile(fileName),
    getSourceFile: (fileName: string) => {
      if (tsFileLoader.isLoadableFile(fileName)) {
        return ts.createSourceFile(fileName, tsFileLoader.loadFile(fileName), compilerOptions.target, false);
      }

      return undefined;
    },
    readFile: fileName => fileName === sourceFile ? code : undefined,
    writeFile: (fileName: string, data: string, writeByteOrderMark: boolean) => outputs.push({ fileName, data, writeByteOrderMark }),
    getDefaultLibFileName: () => 'lib.d.ts',
    useCaseSensitiveFileNames: () => false,
    getCanonicalFileName: fileName => fileName,
    getCurrentDirectory: () => '',
    getNewLine: () => '\n'
  };

  const program = ts.createProgram([sourceFile], compilerOptions, compilerHost);

  const diagnostics = [
    ...program.getSemanticDiagnostics(),
    ...program.getSyntacticDiagnostics(),
    ...program.getDeclarationDiagnostics()
  ];

  if (!diagnostics.length) {
    program.emit();
  }

  return {
    diagnostics: diagnostics.map(diagnosticsFormatter),
    outputs
  };
};
